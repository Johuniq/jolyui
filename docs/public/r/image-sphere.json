{
  "name": "image-sphere",
  "type": "registry:ui",
  "dependencies": [
    "lucide-react"
  ],
  "files": [
    {
      "path": "ui/image-sphere.tsx",
      "content": "import { X } from \"lucide-react\";\nimport Image from \"next/image\";\nimport type React from \"react\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\n\nexport interface Position3D {\n  x: number;\n  y: number;\n  z: number;\n}\n\nexport interface SphericalPosition {\n  theta: number; // Azimuth angle in degrees\n  phi: number; // Polar angle in degrees\n  radius: number; // Distance from center\n}\n\nexport interface WorldPosition extends Position3D {\n  scale: number;\n  zIndex: number;\n  isVisible: boolean;\n  fadeOpacity: number;\n  originalIndex: number;\n}\n\nexport interface ImageData {\n  id: string;\n  src: string;\n  alt: string;\n  title?: string;\n  description?: string;\n}\n\nexport interface SphereImageGridProps {\n  images?: ImageData[];\n  containerSize?: number;\n  sphereRadius?: number;\n  dragSensitivity?: number;\n  momentumDecay?: number;\n  maxRotationSpeed?: number;\n  baseImageScale?: number;\n  hoverScale?: number;\n  perspective?: number;\n  autoRotate?: boolean;\n  autoRotateSpeed?: number;\n  className?: string;\n}\n\ninterface RotationState {\n  x: number;\n  y: number;\n  z: number;\n}\n\ninterface VelocityState {\n  x: number;\n  y: number;\n}\n\ninterface MousePosition {\n  x: number;\n  y: number;\n}\n\n// ==========================================\n// CONSTANTS & CONFIGURATION\n// ==========================================\n\nconst SPHERE_MATH = {\n  degreesToRadians: (degrees: number): number => degrees * (Math.PI / 180),\n  radiansToDegrees: (radians: number): number => radians * (180 / Math.PI),\n\n  sphericalToCartesian: (\n    radius: number,\n    theta: number,\n    phi: number,\n  ): Position3D => ({\n    x: radius * Math.sin(phi) * Math.cos(theta),\n    y: radius * Math.cos(phi),\n    z: radius * Math.sin(phi) * Math.sin(theta),\n  }),\n\n  calculateDistance: (\n    pos: Position3D,\n    center: Position3D = { x: 0, y: 0, z: 0 },\n  ): number => {\n    const dx = pos.x - center.x;\n    const dy = pos.y - center.y;\n    const dz = pos.z - center.z;\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n  },\n\n  normalizeAngle: (angle: number): number => {\n    while (angle > 180) angle -= 360;\n    while (angle < -180) angle += 360;\n    return angle;\n  },\n};\n\n// ==========================================\n// MAIN COMPONENT\n// ==========================================\n\nconst SphereImageGrid: React.FC<SphereImageGridProps> = ({\n  images = [],\n  containerSize = 400,\n  sphereRadius = 200,\n  dragSensitivity = 0.5,\n  momentumDecay = 0.95,\n  maxRotationSpeed = 5,\n  baseImageScale = 0.12,\n  hoverScale: _hoverScale = 1.2,\n  perspective = 1000,\n  autoRotate = false,\n  autoRotateSpeed = 0.3,\n  className = \"\",\n}) => {\n  // ==========================================\n  // STATE & REFS\n  // ==========================================\n\n  const [isMounted, setIsMounted] = useState<boolean>(false);\n  const [rotation, setRotation] = useState<RotationState>({\n    x: 15,\n    y: 15,\n    z: 0,\n  });\n  const [velocity, setVelocity] = useState<VelocityState>({ x: 0, y: 0 });\n  const [isDragging, setIsDragging] = useState<boolean>(false);\n  const [selectedImage, setSelectedImage] = useState<ImageData | null>(null);\n  const [imagePositions, setImagePositions] = useState<SphericalPosition[]>([]);\n  const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);\n\n  const containerRef = useRef<HTMLDivElement>(null);\n  const lastMousePos = useRef<MousePosition>({ x: 0, y: 0 });\n  const animationFrame = useRef<number | null>(null);\n\n  // ==========================================\n  // COMPUTED VALUES\n  // ==========================================\n\n  const actualSphereRadius = sphereRadius || containerSize * 0.5;\n  const baseImageSize = containerSize * baseImageScale;\n\n  // ==========================================\n  // UTILITY FUNCTIONS\n  // ==========================================\n\n  const generateSpherePositions = useCallback((): SphericalPosition[] => {\n    const positions: SphericalPosition[] = [];\n    const imageCount = images.length;\n\n    // Use Fibonacci sphere distribution for even coverage\n    const goldenRatio = (1 + Math.sqrt(5)) / 2;\n    const angleIncrement = (2 * Math.PI) / goldenRatio;\n\n    for (let i = 0; i < imageCount; i++) {\n      // Fibonacci sphere distribution\n      const t = i / imageCount;\n      const inclination = Math.acos(1 - 2 * t);\n      const azimuth = angleIncrement * i;\n\n      // Convert to degrees and focus on front hemisphere\n      let phi = inclination * (180 / Math.PI);\n      let theta = (azimuth * (180 / Math.PI)) % 360;\n\n      // Better pole coverage - reach poles but avoid extreme mathematical issues\n      const poleBonus = (Math.abs(phi - 90) / 90) ** 0.6 * 35; // Moderate boost toward poles\n      if (phi < 90) {\n        phi = Math.max(5, phi - poleBonus); // Reach closer to top pole (15° minimum)\n      } else {\n        phi = Math.min(175, phi + poleBonus); // Reach closer to bottom pole (165° maximum)\n      }\n\n      // Map to fuller vertical range - covers poles but avoids extremes\n      phi = 15 + (phi / 180) * 150; // Map to 15-165 degrees for pole coverage with stability\n\n      // Add slight randomization to prevent perfect patterns\n      const randomOffset = (Math.random() - 0.5) * 20;\n      theta = (theta + randomOffset) % 360;\n      phi = Math.max(0, Math.min(180, phi + (Math.random() - 0.5) * 10));\n\n      positions.push({\n        theta: theta,\n        phi: phi,\n        radius: actualSphereRadius,\n      });\n    }\n\n    return positions;\n  }, [images.length, actualSphereRadius]);\n\n  const calculateWorldPositions = useCallback((): WorldPosition[] => {\n    const positions = imagePositions.map((pos, index) => {\n      // Apply rotation using proper 3D rotation matrices\n      const thetaRad = SPHERE_MATH.degreesToRadians(pos.theta);\n      const phiRad = SPHERE_MATH.degreesToRadians(pos.phi);\n      const rotXRad = SPHERE_MATH.degreesToRadians(rotation.x);\n      const rotYRad = SPHERE_MATH.degreesToRadians(rotation.y);\n\n      // Initial position on sphere\n      let x = pos.radius * Math.sin(phiRad) * Math.cos(thetaRad);\n      let y = pos.radius * Math.cos(phiRad);\n      let z = pos.radius * Math.sin(phiRad) * Math.sin(thetaRad);\n\n      // Apply Y-axis rotation (horizontal drag)\n      const x1 = x * Math.cos(rotYRad) + z * Math.sin(rotYRad);\n      const z1 = -x * Math.sin(rotYRad) + z * Math.cos(rotYRad);\n      x = x1;\n      z = z1;\n\n      // Apply X-axis rotation (vertical drag)\n      const y2 = y * Math.cos(rotXRad) - z * Math.sin(rotXRad);\n      const z2 = y * Math.sin(rotXRad) + z * Math.cos(rotXRad);\n      y = y2;\n      z = z2;\n\n      const worldPos: Position3D = { x, y, z };\n\n      // Calculate visibility with smooth fade zones\n      const fadeZoneStart = -10; // Start fading out\n      const fadeZoneEnd = -30; // Completely hidden\n      const isVisible = worldPos.z > fadeZoneEnd;\n\n      // Calculate fade opacity based on Z position\n      let fadeOpacity = 1;\n      if (worldPos.z <= fadeZoneStart) {\n        // Linear fade from 1 to 0 as Z goes from fadeZoneStart to fadeZoneEnd\n        fadeOpacity = Math.max(\n          0,\n          (worldPos.z - fadeZoneEnd) / (fadeZoneStart - fadeZoneEnd),\n        );\n      }\n\n      // Check if this image originated from a pole position\n      const isPoleImage = pos.phi < 30 || pos.phi > 150; // Images from extreme angles\n\n      // Calculate distance from center for scaling (in 2D screen space)\n      const distanceFromCenter = Math.sqrt(\n        worldPos.x * worldPos.x + worldPos.y * worldPos.y,\n      );\n      const maxDistance = actualSphereRadius;\n      const distanceRatio = Math.min(distanceFromCenter / maxDistance, 1);\n\n      // Scale based on distance from center - be more forgiving for pole images\n      const distancePenalty = isPoleImage ? 0.4 : 0.7; // Less penalty for pole images\n      const centerScale = Math.max(0.3, 1 - distanceRatio * distancePenalty);\n\n      // Also consider Z-depth for additional scaling\n      const depthScale =\n        (worldPos.z + actualSphereRadius) / (2 * actualSphereRadius);\n      const scale = centerScale * Math.max(0.5, 0.8 + depthScale * 0.3);\n\n      return {\n        ...worldPos,\n        scale,\n        zIndex: Math.round(1000 + worldPos.z),\n        isVisible,\n        fadeOpacity,\n        originalIndex: index,\n      };\n    });\n\n    // Apply collision detection to prevent overlaps\n    const adjustedPositions = [...positions];\n\n    for (let i = 0; i < adjustedPositions.length; i++) {\n      const pos = adjustedPositions[i];\n      if (!pos?.isVisible) continue;\n\n      let adjustedScale = pos.scale;\n      const imageSize = baseImageSize * adjustedScale;\n\n      // Check for overlaps with other visible images\n      for (let j = 0; j < adjustedPositions.length; j++) {\n        if (i === j) continue;\n\n        const other = adjustedPositions[j];\n        if (!other?.isVisible) continue;\n\n        const otherSize = baseImageSize * other.scale;\n\n        // Calculate 2D distance between images on screen\n        const dx = pos.x - other.x;\n        const dy = pos.y - other.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        // Minimum distance to prevent overlap (with more generous padding)\n        const minDistance = (imageSize + otherSize) / 2 + 25;\n\n        if (distance < minDistance && distance > 0) {\n          // More aggressive scale reduction to prevent overlap\n          const overlap = minDistance - distance;\n          const reductionFactor = Math.max(\n            0.4,\n            1 - (overlap / minDistance) * 0.6,\n          );\n          adjustedScale = Math.min(\n            adjustedScale,\n            adjustedScale * reductionFactor,\n          );\n        }\n      }\n\n      adjustedPositions[i] = {\n        ...pos,\n        scale: Math.max(0.25, adjustedScale), // Ensure minimum scale\n        zIndex: pos.zIndex ?? 0, // Ensure zIndex is a number\n      };\n    }\n\n    return adjustedPositions;\n  }, [imagePositions, rotation, actualSphereRadius, baseImageSize]);\n\n  const clampRotationSpeed = useCallback(\n    (speed: number): number => {\n      return Math.max(-maxRotationSpeed, Math.min(maxRotationSpeed, speed));\n    },\n    [maxRotationSpeed],\n  );\n\n  // ==========================================\n  // PHYSICS & MOMENTUM\n  // ==========================================\n\n  const updateMomentum = useCallback(() => {\n    if (isDragging) return;\n\n    setVelocity((prev) => {\n      const newVelocity = {\n        x: prev.x * momentumDecay,\n        y: prev.y * momentumDecay,\n      };\n\n      // Stop animation if velocity is too low and auto-rotate is off\n      if (\n        !autoRotate &&\n        Math.abs(newVelocity.x) < 0.01 &&\n        Math.abs(newVelocity.y) < 0.01\n      ) {\n        return { x: 0, y: 0 };\n      }\n\n      return newVelocity;\n    });\n\n    setRotation((prev) => {\n      let newY = prev.y;\n\n      // Add auto-rotation to Y axis (horizontal rotation)\n      if (autoRotate) {\n        newY += autoRotateSpeed;\n      }\n\n      // Add momentum-based rotation\n      newY += clampRotationSpeed(velocity.y);\n\n      return {\n        x: SPHERE_MATH.normalizeAngle(prev.x + clampRotationSpeed(velocity.x)),\n        y: SPHERE_MATH.normalizeAngle(newY),\n        z: prev.z,\n      };\n    });\n  }, [\n    isDragging,\n    momentumDecay,\n    velocity,\n    clampRotationSpeed,\n    autoRotate,\n    autoRotateSpeed,\n  ]);\n\n  // ==========================================\n  // EVENT HANDLERS\n  // ==========================================\n\n  const handleMouseDown = useCallback((e: React.MouseEvent) => {\n    e.preventDefault();\n    setIsDragging(true);\n    setVelocity({ x: 0, y: 0 });\n    lastMousePos.current = { x: e.clientX, y: e.clientY };\n  }, []);\n\n  const handleMouseMove = useCallback(\n    (e: MouseEvent) => {\n      if (!isDragging) return;\n\n      const deltaX = e.clientX - lastMousePos.current.x;\n      const deltaY = e.clientY - lastMousePos.current.y;\n\n      const rotationDelta = {\n        x: -deltaY * dragSensitivity,\n        y: deltaX * dragSensitivity,\n      };\n\n      setRotation((prev) => ({\n        x: SPHERE_MATH.normalizeAngle(\n          prev.x + clampRotationSpeed(rotationDelta.x),\n        ),\n        y: SPHERE_MATH.normalizeAngle(\n          prev.y + clampRotationSpeed(rotationDelta.y),\n        ),\n        z: prev.z,\n      }));\n\n      // Update velocity for momentum\n      setVelocity({\n        x: clampRotationSpeed(rotationDelta.x),\n        y: clampRotationSpeed(rotationDelta.y),\n      });\n\n      lastMousePos.current = { x: e.clientX, y: e.clientY };\n    },\n    [isDragging, dragSensitivity, clampRotationSpeed],\n  );\n\n  const handleMouseUp = useCallback(() => {\n    setIsDragging(false);\n  }, []);\n\n  const handleTouchStart = useCallback((e: React.TouchEvent) => {\n    e.preventDefault();\n    const touch = e.touches[0];\n    if (touch) {\n      setIsDragging(true);\n      setVelocity({ x: 0, y: 0 });\n      lastMousePos.current = { x: touch.clientX, y: touch.clientY };\n    }\n  }, []);\n\n  const handleTouchMove = useCallback(\n    (e: TouchEvent) => {\n      if (!isDragging) return;\n      e.preventDefault();\n\n      const touch = e.touches[0];\n      if (!touch) return;\n\n      const deltaX = touch.clientX - lastMousePos.current.x;\n      const deltaY = touch.clientY - lastMousePos.current.y;\n\n      const rotationDelta = {\n        x: -deltaY * dragSensitivity,\n        y: deltaX * dragSensitivity,\n      };\n\n      setRotation((prev) => ({\n        x: SPHERE_MATH.normalizeAngle(\n          prev.x + clampRotationSpeed(rotationDelta.x),\n        ),\n        y: SPHERE_MATH.normalizeAngle(\n          prev.y + clampRotationSpeed(rotationDelta.y),\n        ),\n        z: prev.z,\n      }));\n\n      setVelocity({\n        x: clampRotationSpeed(rotationDelta.x),\n        y: clampRotationSpeed(rotationDelta.y),\n      });\n\n      lastMousePos.current = { x: touch.clientX, y: touch.clientY };\n    },\n    [isDragging, dragSensitivity, clampRotationSpeed],\n  );\n\n  const handleTouchEnd = useCallback(() => {\n    setIsDragging(false);\n  }, []);\n\n  // ==========================================\n  // EFFECTS & LIFECYCLE\n  // ==========================================\n\n  useEffect(() => {\n    setIsMounted(true);\n  }, []);\n\n  useEffect(() => {\n    setImagePositions(generateSpherePositions());\n  }, [generateSpherePositions]);\n\n  useEffect(() => {\n    const animate = () => {\n      updateMomentum();\n      animationFrame.current = requestAnimationFrame(animate);\n    };\n\n    if (isMounted) {\n      animationFrame.current = requestAnimationFrame(animate);\n    }\n\n    return () => {\n      if (animationFrame.current) {\n        cancelAnimationFrame(animationFrame.current);\n      }\n    };\n  }, [isMounted, updateMomentum]);\n\n  useEffect(() => {\n    if (!isMounted) return;\n\n    const container = containerRef.current;\n    if (!container) return;\n\n    // Mouse events\n    document.addEventListener(\"mousemove\", handleMouseMove);\n    document.addEventListener(\"mouseup\", handleMouseUp);\n\n    // Touch events\n    document.addEventListener(\"touchmove\", handleTouchMove, { passive: false });\n    document.addEventListener(\"touchend\", handleTouchEnd);\n\n    return () => {\n      document.removeEventListener(\"mousemove\", handleMouseMove);\n      document.removeEventListener(\"mouseup\", handleMouseUp);\n      document.removeEventListener(\"touchmove\", handleTouchMove);\n      document.removeEventListener(\"touchend\", handleTouchEnd);\n    };\n  }, [\n    isMounted,\n    handleMouseMove,\n    handleMouseUp,\n    handleTouchMove,\n    handleTouchEnd,\n  ]);\n\n  // ==========================================\n  // RENDER HELPERS\n  // ==========================================\n\n  // Calculate world positions once per render\n  const worldPositions = calculateWorldPositions();\n\n  const renderImageNode = useCallback(\n    (image: ImageData, index: number) => {\n      const position = worldPositions[index];\n\n      if (!position || !position.isVisible) return null;\n\n      const imageSize = baseImageSize * position.scale;\n      const isHovered = hoveredIndex === index;\n      const finalScale = isHovered ? Math.min(1.2, 1.2 / position.scale) : 1;\n\n      return (\n        <div\n          key={image.id}\n          role=\"button\"\n          tabIndex={0}\n          className=\"absolute cursor-pointer select-none transition-transform duration-200 ease-out\"\n          style={{\n            width: `${imageSize}px`,\n            height: `${imageSize}px`,\n            left: `${containerSize / 2 + position.x}px`,\n            top: `${containerSize / 2 + position.y}px`,\n            opacity: position.fadeOpacity,\n            transform: `translate(-50%, -50%) scale(${finalScale})`,\n            zIndex: position.zIndex,\n          }}\n          onMouseEnter={() => setHoveredIndex(index)}\n          onMouseLeave={() => setHoveredIndex(null)}\n          onClick={() => setSelectedImage(image)}\n          onKeyDown={(e) => e.key === \"Enter\" && setSelectedImage(image)}\n        >\n          <div className=\"relative h-full w-full overflow-hidden rounded-full border-2 border-white/20 shadow-lg\">\n            <Image\n              src={image.src}\n              alt={image.alt}\n              fill\n              className=\"object-cover\"\n              draggable={false}\n              loading={index < 3 ? \"eager\" : \"lazy\"}\n              unoptimized\n            />\n          </div>\n        </div>\n      );\n    },\n    [worldPositions, baseImageSize, containerSize, hoveredIndex],\n  );\n\n  const renderSpotlightModal = () => {\n    if (!selectedImage) return null;\n\n    return (\n      <div\n        className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/30 p-4\"\n        onClick={() => setSelectedImage(null)}\n        role=\"button\"\n        tabIndex={0}\n        onKeyDown={(e) => e.key === \"Escape\" && setSelectedImage(null)}\n        style={{\n          animation: \"fadeIn 0.3s ease-out\",\n        }}\n      >\n        <div\n          className=\"w-full max-w-md overflow-hidden rounded-xl bg-white\"\n          onClick={(e) => e.stopPropagation()}\n          role=\"dialog\"\n          aria-modal=\"true\"\n          style={{\n            animation: \"scaleIn 0.3s ease-out\",\n          }}\n        >\n          <div className=\"relative aspect-square\">\n            <Image\n              src={selectedImage.src}\n              alt={selectedImage.alt}\n              fill\n              className=\"object-cover\"\n              unoptimized\n            />\n            <button\n              onClick={() => setSelectedImage(null)}\n              className=\"absolute top-2 right-2 flex h-8 w-8 cursor-pointer items-center justify-center rounded-full bg-black bg-opacity-50 text-white transition-all hover:bg-opacity-70\"\n            >\n              <X size={16} />\n            </button>\n          </div>\n\n          {(selectedImage.title || selectedImage.description) && (\n            <div className=\"p-6\">\n              {selectedImage.title && (\n                <h3 className=\"mb-2 font-bold text-xl\">\n                  {selectedImage.title}\n                </h3>\n              )}\n              {selectedImage.description && (\n                <p className=\"text-gray-600\">{selectedImage.description}</p>\n              )}\n            </div>\n          )}\n        </div>\n      </div>\n    );\n  };\n\n  // ==========================================\n  // EARLY RETURNS\n  // ==========================================\n\n  if (!isMounted) {\n    return (\n      <div\n        className=\"flex animate-pulse items-center justify-center rounded-lg bg-gray-100\"\n        style={{ width: containerSize, height: containerSize }}\n      >\n        <div className=\"text-gray-400\">Loading...</div>\n      </div>\n    );\n  }\n\n  if (!images.length) {\n    return (\n      <div\n        className=\"flex items-center justify-center rounded-lg border-2 border-gray-300 border-dashed bg-gray-50\"\n        style={{ width: containerSize, height: containerSize }}\n      >\n        <div className=\"text-center text-gray-400\">\n          <p>No images provided</p>\n          <p className=\"text-sm\">Add images to the images prop</p>\n        </div>\n      </div>\n    );\n  }\n\n  // ==========================================\n  // MAIN RENDER\n  // ==========================================\n\n  return (\n    <>\n      <style>{`\n        @keyframes fadeIn {\n          from { opacity: 0; }\n          to { opacity: 1; }\n        }\n        @keyframes scaleIn {\n          from { transform: scale(0.8); opacity: 0; }\n          to { transform: scale(1); opacity: 1; }\n        }\n      `}</style>\n\n      <div\n        ref={containerRef}\n        className={`relative cursor-grab select-none active:cursor-grabbing ${className}`}\n        style={{\n          width: containerSize,\n          height: containerSize,\n          perspective: `${perspective}px`,\n        }}\n        onMouseDown={handleMouseDown}\n        onTouchStart={handleTouchStart}\n        role=\"button\"\n        aria-label=\"Interactive 3D Image Sphere\"\n        tabIndex={0}\n      >\n        <div className=\"relative h-full w-full\" style={{ zIndex: 10 }}>\n          {images.map((image, index) => renderImageNode(image, index))}\n        </div>\n      </div>\n\n      {renderSpotlightModal()}\n    </>\n  );\n};\n\nexport default SphereImageGrid;\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}