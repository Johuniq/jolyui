{
  "name": "image-sphere",
  "type": "registry:ui",
  "dependencies": [
    "lucide-react"
  ],
  "files": [
    {
      "path": "ui/image-sphere.tsx",
      "content": "import { X } from 'lucide-react';\nimport React, { useCallback, useEffect, useRef, useState } from 'react';\n\nexport interface Position3D {\n  x: number;\n  y: number;\n  z: number;\n}\n\nexport interface SphericalPosition {\n  theta: number;  // Azimuth angle in degrees\n  phi: number;    // Polar angle in degrees\n  radius: number; // Distance from center\n}\n\nexport interface WorldPosition extends Position3D {\n  scale: number;\n  zIndex: number;\n  isVisible: boolean;\n  fadeOpacity: number;\n  originalIndex: number;\n}\n\nexport interface ImageData {\n  id: string;\n  src: string;\n  alt: string;\n  title?: string;\n  description?: string;\n}\n\nexport interface SphereImageGridProps {\n  images?: ImageData[];\n  containerSize?: number;\n  sphereRadius?: number;\n  dragSensitivity?: number;\n  momentumDecay?: number;\n  maxRotationSpeed?: number;\n  baseImageScale?: number;\n  hoverScale?: number;\n  perspective?: number;\n  autoRotate?: boolean;\n  autoRotateSpeed?: number;\n  className?: string;\n}\n\ninterface RotationState {\n  x: number;\n  y: number;\n  z: number;\n}\n\ninterface VelocityState {\n  x: number;\n  y: number;\n}\n\ninterface MousePosition {\n  x: number;\n  y: number;\n}\n\n// ==========================================\n// CONSTANTS & CONFIGURATION\n// ==========================================\n\nconst SPHERE_MATH = {\n  degreesToRadians: (degrees: number): number => degrees * (Math.PI / 180),\n  radiansToDegrees: (radians: number): number => radians * (180 / Math.PI),\n\n  sphericalToCartesian: (radius: number, theta: number, phi: number): Position3D => ({\n    x: radius * Math.sin(phi) * Math.cos(theta),\n    y: radius * Math.cos(phi),\n    z: radius * Math.sin(phi) * Math.sin(theta)\n  }),\n\n  calculateDistance: (pos: Position3D, center: Position3D = { x: 0, y: 0, z: 0 }): number => {\n    const dx = pos.x - center.x;\n    const dy = pos.y - center.y;\n    const dz = pos.z - center.z;\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n  },\n\n  normalizeAngle: (angle: number): number => {\n    while (angle > 180) angle -= 360;\n    while (angle < -180) angle += 360;\n    return angle;\n  }\n};\n\n// ==========================================\n// MAIN COMPONENT\n// ==========================================\n\nconst SphereImageGrid: React.FC<SphereImageGridProps> = ({\n  images = [],\n  containerSize = 400,\n  sphereRadius = 200,\n  dragSensitivity = 0.5,\n  momentumDecay = 0.95,\n  maxRotationSpeed = 5,\n  baseImageScale = 0.12,\n  hoverScale = 1.2,\n  perspective = 1000,\n  autoRotate = false,\n  autoRotateSpeed = 0.3,\n  className = ''\n}) => {\n\n  // ==========================================\n  // STATE & REFS\n  // ==========================================\n\n  const [isMounted, setIsMounted] = useState<boolean>(false);\n  const [rotation, setRotation] = useState<RotationState>({ x: 15, y: 15, z: 0 });\n  const [velocity, setVelocity] = useState<VelocityState>({ x: 0, y: 0 });\n  const [isDragging, setIsDragging] = useState<boolean>(false);\n  const [selectedImage, setSelectedImage] = useState<ImageData | null>(null);\n  const [imagePositions, setImagePositions] = useState<SphericalPosition[]>([]);\n  const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);\n\n  const containerRef = useRef<HTMLDivElement>(null);\n  const lastMousePos = useRef<MousePosition>({ x: 0, y: 0 });\n  const animationFrame = useRef<number | null>(null);\n\n  // ==========================================\n  // COMPUTED VALUES\n  // ==========================================\n\n  const actualSphereRadius = sphereRadius || containerSize * 0.5;\n  const baseImageSize = containerSize * baseImageScale;\n\n  // ==========================================\n  // UTILITY FUNCTIONS\n  // ==========================================\n\n  const generateSpherePositions = useCallback((): SphericalPosition[] => {\n    const positions: SphericalPosition[] = [];\n    const imageCount = images.length;\n\n    // Use Fibonacci sphere distribution for even coverage\n    const goldenRatio = (1 + Math.sqrt(5)) / 2;\n    const angleIncrement = 2 * Math.PI / goldenRatio;\n\n    for (let i = 0; i < imageCount; i++) {\n      // Fibonacci sphere distribution\n      const t = i / imageCount;\n      const inclination = Math.acos(1 - 2 * t);\n      const azimuth = angleIncrement * i;\n\n      // Convert to degrees and focus on front hemisphere\n      let phi = inclination * (180 / Math.PI);\n      let theta = (azimuth * (180 / Math.PI)) % 360;\n\n      // Better pole coverage - reach poles but avoid extreme mathematical issues\n      const poleBonus = Math.pow(Math.abs(phi - 90) / 90, 0.6) * 35; // Moderate boost toward poles\n      if (phi < 90) {\n        phi = Math.max(5, phi - poleBonus); // Reach closer to top pole (15° minimum)\n      } else {\n        phi = Math.min(175, phi + poleBonus); // Reach closer to bottom pole (165° maximum)\n      }\n\n      // Map to fuller vertical range - covers poles but avoids extremes\n      phi = 15 + (phi / 180) * 150; // Map to 15-165 degrees for pole coverage with stability\n\n      // Add slight randomization to prevent perfect patterns\n      const randomOffset = (Math.random() - 0.5) * 20;\n      theta = (theta + randomOffset) % 360;\n      phi = Math.max(0, Math.min(180, phi + (Math.random() - 0.5) * 10));\n\n      positions.push({\n        theta: theta,\n        phi: phi,\n        radius: actualSphereRadius\n      });\n    }\n\n    return positions;\n  }, [images.length, actualSphereRadius]);\n\n  const calculateWorldPositions = useCallback((): WorldPosition[] => {\n    const positions = imagePositions.map((pos, index) => {\n      // Apply rotation using proper 3D rotation matrices\n      const thetaRad = SPHERE_MATH.degreesToRadians(pos.theta);\n      const phiRad = SPHERE_MATH.degreesToRadians(pos.phi);\n      const rotXRad = SPHERE_MATH.degreesToRadians(rotation.x);\n      const rotYRad = SPHERE_MATH.degreesToRadians(rotation.y);\n\n      // Initial position on sphere\n      let x = pos.radius * Math.sin(phiRad) * Math.cos(thetaRad);\n      let y = pos.radius * Math.cos(phiRad);\n      let z = pos.radius * Math.sin(phiRad) * Math.sin(thetaRad);\n\n      // Apply Y-axis rotation (horizontal drag)\n      const x1 = x * Math.cos(rotYRad) + z * Math.sin(rotYRad);\n      const z1 = -x * Math.sin(rotYRad) + z * Math.cos(rotYRad);\n      x = x1;\n      z = z1;\n\n      // Apply X-axis rotation (vertical drag)\n      const y2 = y * Math.cos(rotXRad) - z * Math.sin(rotXRad);\n      const z2 = y * Math.sin(rotXRad) + z * Math.cos(rotXRad);\n      y = y2;\n      z = z2;\n\n      const worldPos: Position3D = { x, y, z };\n\n      // Calculate visibility with smooth fade zones\n      const fadeZoneStart = -10;  // Start fading out\n      const fadeZoneEnd = -30;    // Completely hidden\n      const isVisible = worldPos.z > fadeZoneEnd;\n\n      // Calculate fade opacity based on Z position\n      let fadeOpacity = 1;\n      if (worldPos.z <= fadeZoneStart) {\n        // Linear fade from 1 to 0 as Z goes from fadeZoneStart to fadeZoneEnd\n        fadeOpacity = Math.max(0, (worldPos.z - fadeZoneEnd) / (fadeZoneStart - fadeZoneEnd));\n      }\n\n      // Check if this image originated from a pole position\n      const isPoleImage = pos.phi < 30 || pos.phi > 150; // Images from extreme angles\n\n      // Calculate distance from center for scaling (in 2D screen space)\n      const distanceFromCenter = Math.sqrt(worldPos.x * worldPos.x + worldPos.y * worldPos.y);\n      const maxDistance = actualSphereRadius;\n      const distanceRatio = Math.min(distanceFromCenter / maxDistance, 1);\n\n      // Scale based on distance from center - be more forgiving for pole images\n      const distancePenalty = isPoleImage ? 0.4 : 0.7; // Less penalty for pole images\n      const centerScale = Math.max(0.3, 1 - distanceRatio * distancePenalty);\n\n      // Also consider Z-depth for additional scaling\n      const depthScale = (worldPos.z + actualSphereRadius) / (2 * actualSphereRadius);\n      const scale = centerScale * Math.max(0.5, 0.8 + depthScale * 0.3);\n\n      return {\n        ...worldPos,\n        scale,\n        zIndex: Math.round(1000 + worldPos.z),\n        isVisible,\n        fadeOpacity,\n        originalIndex: index\n      };\n    });\n\n    // Apply collision detection to prevent overlaps\n    const adjustedPositions = [...positions];\n\n    for (let i = 0; i < adjustedPositions.length; i++) {\n      const pos = adjustedPositions[i];\n      if (!pos.isVisible) continue;\n\n      let adjustedScale = pos.scale;\n      const imageSize = baseImageSize * adjustedScale;\n\n      // Check for overlaps with other visible images\n      for (let j = 0; j < adjustedPositions.length; j++) {\n        if (i === j) continue;\n\n        const other = adjustedPositions[j];\n        if (!other.isVisible) continue;\n\n        const otherSize = baseImageSize * other.scale;\n\n        // Calculate 2D distance between images on screen\n        const dx = pos.x - other.x;\n        const dy = pos.y - other.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        // Minimum distance to prevent overlap (with more generous padding)\n        const minDistance = (imageSize + otherSize) / 2 + 25;\n\n        if (distance < minDistance && distance > 0) {\n          // More aggressive scale reduction to prevent overlap\n          const overlap = minDistance - distance;\n          const reductionFactor = Math.max(0.4, 1 - (overlap / minDistance) * 0.6);\n          adjustedScale = Math.min(adjustedScale, adjustedScale * reductionFactor);\n        }\n      }\n\n      adjustedPositions[i] = {\n        ...pos,\n        scale: Math.max(0.25, adjustedScale) // Ensure minimum scale\n      };\n    }\n\n    return adjustedPositions;\n  }, [imagePositions, rotation, actualSphereRadius, baseImageSize]);\n\n  const clampRotationSpeed = useCallback((speed: number): number => {\n    return Math.max(-maxRotationSpeed, Math.min(maxRotationSpeed, speed));\n  }, [maxRotationSpeed]);\n\n  // ==========================================\n  // PHYSICS & MOMENTUM\n  // ==========================================\n\n  const updateMomentum = useCallback(() => {\n    if (isDragging) return;\n\n    setVelocity(prev => {\n      const newVelocity = {\n        x: prev.x * momentumDecay,\n        y: prev.y * momentumDecay\n      };\n\n      // Stop animation if velocity is too low and auto-rotate is off\n      if (!autoRotate && Math.abs(newVelocity.x) < 0.01 && Math.abs(newVelocity.y) < 0.01) {\n        return { x: 0, y: 0 };\n      }\n\n      return newVelocity;\n    });\n\n    setRotation(prev => {\n      let newY = prev.y;\n\n      // Add auto-rotation to Y axis (horizontal rotation)\n      if (autoRotate) {\n        newY += autoRotateSpeed;\n      }\n\n      // Add momentum-based rotation\n      newY += clampRotationSpeed(velocity.y);\n\n      return {\n        x: SPHERE_MATH.normalizeAngle(prev.x + clampRotationSpeed(velocity.x)),\n        y: SPHERE_MATH.normalizeAngle(newY),\n        z: prev.z\n      };\n    });\n  }, [isDragging, momentumDecay, velocity, clampRotationSpeed, autoRotate, autoRotateSpeed]);\n\n  // ==========================================\n  // EVENT HANDLERS\n  // ==========================================\n\n  const handleMouseDown = useCallback((e: React.MouseEvent) => {\n    e.preventDefault();\n    setIsDragging(true);\n    setVelocity({ x: 0, y: 0 });\n    lastMousePos.current = { x: e.clientX, y: e.clientY };\n  }, []);\n\n  const handleMouseMove = useCallback((e: MouseEvent) => {\n    if (!isDragging) return;\n\n    const deltaX = e.clientX - lastMousePos.current.x;\n    const deltaY = e.clientY - lastMousePos.current.y;\n\n    const rotationDelta = {\n      x: -deltaY * dragSensitivity,\n      y: deltaX * dragSensitivity\n    };\n\n    setRotation(prev => ({\n      x: SPHERE_MATH.normalizeAngle(prev.x + clampRotationSpeed(rotationDelta.x)),\n      y: SPHERE_MATH.normalizeAngle(prev.y + clampRotationSpeed(rotationDelta.y)),\n      z: prev.z\n    }));\n\n    // Update velocity for momentum\n    setVelocity({\n      x: clampRotationSpeed(rotationDelta.x),\n      y: clampRotationSpeed(rotationDelta.y)\n    });\n\n    lastMousePos.current = { x: e.clientX, y: e.clientY };\n  }, [isDragging, dragSensitivity, clampRotationSpeed]);\n\n  const handleMouseUp = useCallback(() => {\n    setIsDragging(false);\n  }, []);\n\n  const handleTouchStart = useCallback((e: React.TouchEvent) => {\n    e.preventDefault();\n    const touch = e.touches[0];\n    setIsDragging(true);\n    setVelocity({ x: 0, y: 0 });\n    lastMousePos.current = { x: touch.clientX, y: touch.clientY };\n  }, []);\n\n  const handleTouchMove = useCallback((e: TouchEvent) => {\n    if (!isDragging) return;\n    e.preventDefault();\n\n    const touch = e.touches[0];\n    const deltaX = touch.clientX - lastMousePos.current.x;\n    const deltaY = touch.clientY - lastMousePos.current.y;\n\n    const rotationDelta = {\n      x: -deltaY * dragSensitivity,\n      y: deltaX * dragSensitivity\n    };\n\n    setRotation(prev => ({\n      x: SPHERE_MATH.normalizeAngle(prev.x + clampRotationSpeed(rotationDelta.x)),\n      y: SPHERE_MATH.normalizeAngle(prev.y + clampRotationSpeed(rotationDelta.y)),\n      z: prev.z\n    }));\n\n    setVelocity({\n      x: clampRotationSpeed(rotationDelta.x),\n      y: clampRotationSpeed(rotationDelta.y)\n    });\n\n    lastMousePos.current = { x: touch.clientX, y: touch.clientY };\n  }, [isDragging, dragSensitivity, clampRotationSpeed]);\n\n  const handleTouchEnd = useCallback(() => {\n    setIsDragging(false);\n  }, []);\n\n  // ==========================================\n  // EFFECTS & LIFECYCLE\n  // ==========================================\n\n  useEffect(() => {\n    setIsMounted(true);\n  }, []);\n\n  useEffect(() => {\n    setImagePositions(generateSpherePositions());\n  }, [generateSpherePositions]);\n\n  useEffect(() => {\n    const animate = () => {\n      updateMomentum();\n      animationFrame.current = requestAnimationFrame(animate);\n    };\n\n    if (isMounted) {\n      animationFrame.current = requestAnimationFrame(animate);\n    }\n\n    return () => {\n      if (animationFrame.current) {\n        cancelAnimationFrame(animationFrame.current);\n      }\n    };\n  }, [isMounted, updateMomentum]);\n\n  useEffect(() => {\n    if (!isMounted) return;\n\n    const container = containerRef.current;\n    if (!container) return;\n\n    // Mouse events\n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp);\n\n    // Touch events\n    document.addEventListener('touchmove', handleTouchMove, { passive: false });\n    document.addEventListener('touchend', handleTouchEnd);\n\n    return () => {\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n      document.removeEventListener('touchmove', handleTouchMove);\n      document.removeEventListener('touchend', handleTouchEnd);\n    };\n  }, [isMounted, handleMouseMove, handleMouseUp, handleTouchMove, handleTouchEnd]);\n\n  // ==========================================\n  // RENDER HELPERS\n  // ==========================================\n\n  // Calculate world positions once per render\n  const worldPositions = calculateWorldPositions();\n\n  const renderImageNode = useCallback((image: ImageData, index: number) => {\n    const position = worldPositions[index];\n\n    if (!position || !position.isVisible) return null;\n\n    const imageSize = baseImageSize * position.scale;\n    const isHovered = hoveredIndex === index;\n    const finalScale = isHovered ? Math.min(1.2, 1.2 / position.scale) : 1;\n\n    return (\n      <div\n        key={image.id}\n        className=\"absolute cursor-pointer select-none transition-transform duration-200 ease-out\"\n        style={{\n          width: `${imageSize}px`,\n          height: `${imageSize}px`,\n          left: `${containerSize/2 + position.x}px`,\n          top: `${containerSize/2 + position.y}px`,\n          opacity: position.fadeOpacity,\n          transform: `translate(-50%, -50%) scale(${finalScale})`,\n          zIndex: position.zIndex\n        }}\n        onMouseEnter={() => setHoveredIndex(index)}\n        onMouseLeave={() => setHoveredIndex(null)}\n        onClick={() => setSelectedImage(image)}\n      >\n        <div className=\"relative w-full h-full rounded-full overflow-hidden shadow-lg border-2 border-white/20\">\n          <img\n            src={image.src}\n            alt={image.alt}\n            className=\"w-full h-full object-cover\"\n            draggable={false}\n            loading={index < 3 ? 'eager' : 'lazy'}\n          />\n        </div>\n      </div>\n    );\n  }, [worldPositions, baseImageSize, containerSize, hoveredIndex]);\n\n  const renderSpotlightModal = () => {\n    if (!selectedImage) return null;\n\n    return (\n      <div\n        className=\"fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/30\"\n        onClick={() => setSelectedImage(null)}\n        style={{\n          animation: 'fadeIn 0.3s ease-out'\n        }}\n      >\n        <div\n          className=\"bg-white rounded-xl max-w-md w-full overflow-hidden\"\n          onClick={(e) => e.stopPropagation()}\n          style={{\n            animation: 'scaleIn 0.3s ease-out'\n          }}\n        >\n          <div className=\"relative aspect-square\">\n            <img\n              src={selectedImage.src}\n              alt={selectedImage.alt}\n              className=\"w-full h-full object-cover\"\n            />\n            <button\n              onClick={() => setSelectedImage(null)}\n              className=\"absolute top-2 right-2 w-8 h-8 bg-black bg-opacity-50 rounded-full text-white flex items-center justify-center hover:bg-opacity-70 transition-all cursor-pointer\"\n            >\n              <X size={16} />\n            </button>\n          </div>\n\n          {(selectedImage.title || selectedImage.description) && (\n            <div className=\"p-6\">\n              {selectedImage.title && (\n                <h3 className=\"text-xl font-bold mb-2\">{selectedImage.title}</h3>\n              )}\n              {selectedImage.description && (\n                <p className=\"text-gray-600\">{selectedImage.description}</p>\n              )}\n            </div>\n          )}\n        </div>\n      </div>\n    );\n  };\n\n  // ==========================================\n  // EARLY RETURNS\n  // ==========================================\n\n  if (!isMounted) {\n    return (\n      <div\n        className=\"bg-gray-100 rounded-lg animate-pulse flex items-center justify-center\"\n        style={{ width: containerSize, height: containerSize }}\n      >\n        <div className=\"text-gray-400\">Loading...</div>\n      </div>\n    );\n  }\n\n  if (!images.length) {\n    return (\n      <div\n        className=\"bg-gray-50 rounded-lg border-2 border-dashed border-gray-300 flex items-center justify-center\"\n        style={{ width: containerSize, height: containerSize }}\n      >\n        <div className=\"text-gray-400 text-center\">\n          <p>No images provided</p>\n          <p className=\"text-sm\">Add images to the images prop</p>\n        </div>\n      </div>\n    );\n  }\n\n  // ==========================================\n  // MAIN RENDER\n  // ==========================================\n\n  return (\n    <>\n      <style>{`\n        @keyframes fadeIn {\n          from { opacity: 0; }\n          to { opacity: 1; }\n        }\n        @keyframes scaleIn {\n          from { transform: scale(0.8); opacity: 0; }\n          to { transform: scale(1); opacity: 1; }\n        }\n      `}</style>\n\n      <div\n        ref={containerRef}\n        className={`relative select-none cursor-grab active:cursor-grabbing ${className}`}\n        style={{\n          width: containerSize,\n          height: containerSize,\n          perspective: `${perspective}px`\n        }}\n        onMouseDown={handleMouseDown}\n        onTouchStart={handleTouchStart}\n      >\n        <div className=\"relative w-full h-full\" style={{ zIndex: 10 }}>\n          {images.map((image, index) => renderImageNode(image, index))}\n        </div>\n      </div>\n\n      {renderSpotlightModal()}\n    </>\n  );\n};\n\nexport default SphereImageGrid;",
      "type": "registry:ui",
      "target": ""
    }
  ]
}